import math

# --------------------------------------------------------------
# Q1. Series sums for N terms (print to 9 decimal places)
#   (a) 1 + 1/2 + 1/3 + ... + 1/N
#   (b) 1/1! + 1/2! + ... + 1/N!
#   (c) 1 - 1/2^2 + 1/3^2 - 1/4^2 + ... (N terms, alternating)
#   (d) 1 + x/1! + x^2/2! + ... + x^N/N!
#   (e) F(x) = 1 + x/1 + x^2/2 + x^3/3 + ... + x^N/N
# --------------------------------------------------------------

print("\n========== Q1: SERIES SUMS (N terms) ==========\n")

N = int(input("Enter N (positive integer): "))
x_for_d = float(input("Enter x for (d): "))
x_for_e = float(input("Enter x for (e): "))

# helper: factorial iterative (no recursion to avoid overhead)
def fact(n):
    value = 1
    k = 1
    while k <= n:
        value *= k
        k += 1
    return value

# (a) Harmonic partial sum
sum_a = 0.0
i = 1
while i <= N:
    sum_a += 1.0 / i
    i += 1

# (b) Sum of reciprocals of factorials
sum_b = 0.0
j = 1
while j <= N:
    sum_b += 1.0 / fact(j)
    j += 1

# (c) Alternating by sign with 1/k^2
sum_c = 0.0
k = 1
sign = 1.0
while k <= N:
    sum_c += sign * (1.0 / (k * k))
    sign = -sign
    k += 1

# (d) e^x–style with factorial in denominator
sum_d = 1.0  # term for n=0
n_d = 1
while n_d <= N:
    sum_d += (x_for_d ** n_d) / fact(n_d)
    n_d += 1

# (e) x-series with division by index (no factorial)
sum_e = 1.0  # start with 1 (n=0)
n_e = 1
while n_e <= N:
    sum_e += (x_for_e ** n_e) / n_e
    n_e += 1

print("Q1(a) =", format(sum_a, ".9f"))
print("Q1(b) =", format(sum_b, ".9f"))
print("Q1(c) =", format(sum_c, ".9f"))
print("Q1(d) =", format(sum_d, ".9f"))
print("Q1(e) =", format(sum_e, ".9f"))

# Explanation:
# - We build each series term-by-term in a loop.
# - A small factorial helper avoids recursion and is reused.
# - (c) alternates sign by flipping +/− each iteration.
# - (d) divides by n! like the Taylor series for e^x.
# - (e) divides by n (not factorial), starting sum at 1 for the n=0 term.


# --------------------------------------------------------------
# Q2. Compute sums until successive values differ by less than ε
#   (a) F = Σ (1/2)^n for n=1..∞
#   (b) F(x) = x − x^3/3! + x^5/5! − ...
#   (c) F(x) = 1 − x^2/2! + x^4/4! − ...
#   Report F and minimal number of terms i such that |Fi - F(i-1)| < ε
# --------------------------------------------------------------

print("\n========== Q2: EPSILON-BASED SERIES (until |Δ| < ε) ==========\n")

epsilon = float(input("Enter epsilon (positive small number): "))
x_b = float(input("Enter x for Q2(b): "))
x_c = float(input("Enter x for Q2(c): "))

# (a) geometric series with ratio 1/2 starting from n=1
F_prev = 0.0
F_curr = 0.0
n = 1
while True:
    F_curr += (1.0 / 2.0) ** n
    if abs(F_curr - F_prev) < epsilon:
        break
    F_prev = F_curr
    n += 1
print('Q2(a): F =', format(F_curr, ".9f"), '| terms =', n)

# (b) sine-like odd powers alternating signs
F_prev = 0.0
F_curr = 0.0
i_term = 0  # 0th odd power is x^1
sign = 1.0
while True:
    power = 2 * i_term + 1
    term = sign * (x_b ** power) / fact(power)
    F_curr += term
    if abs(F_curr - F_prev) < epsilon and i_term > 0:
        break
    F_prev = F_curr
    sign = -sign
    i_term += 1
print('Q2(b): F =', format(F_curr, ".9f"), '| terms =', i_term + 1)

# (c) cosine-like even powers alternating signs
F_prev = 0.0
F_curr = 0.0
i_term = 0  # even powers: 0,2,4,...
sign = 1.0
while True:
    power = 2 * i_term
    term = sign * (x_c ** power) / fact(power)
    F_curr += term
    if abs(F_curr - F_prev) < epsilon and i_term > 0:
        break
    F_prev = F_curr
    sign = -sign
    i_term += 1
print('Q2(c): F =', format(F_curr, ".9f"), '| terms =', i_term)

# Explanation:
# - We accumulate partial sums Fi and compare with the previous Fi-1.
# - Stop when the change is less than epsilon.
# - (a) geometric, (b) odd-power sine expansion, (c) even-power cosine expansion.
# - We track minimal term count needed to satisfy the threshold.
# - Print F to 9 decimals for precision.


# --------------------------------------------------------------
# Q3. Sum of primes between x and y (inclusive)
# --------------------------------------------------------------

print("\n========== Q3: SUM OF PRIMES IN RANGE ==========\n")

x_low = int(input("Enter lower bound x: "))
y_high = int(input("Enter upper bound y: "))

def is_prime(n_value):
    if n_value <= 1:
        return False
    if n_value <= 3:
        return True
    if n_value % 2 == 0 or n_value % 3 == 0:
        return False
    test = 5
    while test * test <= n_value:
        if n_value % test == 0 or n_value % (test + 2) == 0:
            return False
        test += 6
    return True

sum_primes = 0
value = x_low
while value <= y_high:
    if is_prime(value):
        sum_primes += value
    value += 1

print("Sum of primes between", x_low, "and", y_high, "=", sum_primes)

# Explanation:
# - Efficient primality test up to sqrt(n) via 6k±1 optimization.
# - We scan the interval and accumulate primes only.
# - Handles ranges where x ≤ y; if x>y you can swap, but spec doesn’t require.


# --------------------------------------------------------------
# Q4. Patterns with letters/stars (lines taken from user)
#   (a) Right-leaning triangle of A.. letters
#   (b) Hollow A..B frame with ABCDE base
#   (c) Centered letter pyramid (A, ABC, ABCDE, ...)
#   (d) Star pattern (given shape)
# --------------------------------------------------------------

print("\n========== Q4: PATTERNS ==========\n")

lines = int(input("Enter number of lines: "))

# (a)
print("\nQ4(a)")
row = 1
while row <= lines:
    # print spaces then letters A.. up to row
    pad = "  " * (lines - row)
    letters = ""
    c = 0
    while c < row:
        letters += chr(ord('A') + c)
        c += 1
    print(pad + letters)
    row += 1

# (b)
print("\nQ4(b)")
# Top A
print("A")
# Upper hollow lines
inner = 1
while inner <= lines - 2:
    # A then spaces then B
    print("A" + " " * (inner + 1) + "B")
    inner += 1
# Base line ABCDE (as shown in typical sample)
if lines >= 2:
    base = ""
    idx = 0
    while idx < 5:
        base += chr(ord('A') + idx)
        idx += 1
    print(base)

# (c)
print("\nQ4(c)")
row = 1
while row <= lines:
    # centered odd-length growth: A, ABC, ABCDE...
    pad = " " * (2 * (lines - row))
    letters = ""
    count = 0
    length = 2 * row - 1
    while count < length:
        ch = chr(ord('A') + (count % 26))
        letters += ch
        count += 1
    print(pad + letters)
    row += 1

# (d) star pattern
print("\nQ4(d)")
# Build a 5x5 shape similar to a hollow square with diagonals near corners.
size = 5
r = 1
while r <= size:
    c = 1
    line = ""
    while c <= size:
        star = False
        if r == 1 or r == size:
            star = True
        elif c == 1 or c == size:
            star = True
        elif (r == 2 and c == 2) or (r == 3 and c == 3) or (r == 4 and c == 4):
            star = True
        elif (r == 2 and c == size-1) or (r == 4 and c == 2):
            star = True
        line += ("* " if star else "  ")
        c += 1
    print(line.rstrip())
    r += 1

# Explanation:
# - Each subpattern uses while loops with manual spacing.
# - (a) builds A.. sequences with left padding to tilt right.
# - (b) draws a vertical A...B frame and a fixed ABCDE base as shown.
# - (c) centers an odd-length row of letters (1,3,5,...).
# - (d) constructs a 5×5 grid and turns on star positions to match the sample.


# --------------------------------------------------------------
# Q5. (If present in your PDF) — Add any extra tasks here as needed.
# This template includes up to Q4 per the common Lab-7 structure you shared.
# --------------------------------------------------------------
